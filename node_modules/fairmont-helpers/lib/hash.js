// Generated by CoffeeScript 1.10.0
(function() {
  var Base64Words, Crypto, Method, async, base64, base64URL, fromBase64Words, fs, isBuffer, isString, md5, promise, randomBytes, randomKey, randomWords, ref, ref1, toBase64Words;

  fs = require("fs");

  Crypto = require("crypto");

  Method = require("fairmont-multimethods").Method;

  ref = require("./type"), isBuffer = ref.isBuffer, isString = ref.isString;

  Base64Words = require("base64-words");

  ref1 = require("./promise"), promise = ref1.promise, async = ref1.async;

  md5 = Method.create();

  Method.define(md5, isString, function(string) {
    return Crypto.createHash('md5').update(string, 'utf-8').digest("hex");
  });

  Method.define(md5, isBuffer, function(buffer) {
    return Crypto.createHash('md5').update(buffer, 'binary').digest("hex");
  });

  base64 = Method.create();

  Method.define(base64, isString, function(string) {
    return base64(new Buffer(string));
  });

  Method.define(base64, isBuffer, function(buffer) {
    return buffer.toString('base64');
  });

  base64URL = function(buffer) {
    return base64(buffer).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  };

  toBase64Words = function(buffer) {
    return Base64Words.fromBase64(base64URL(buffer));
  };

  fromBase64Words = function(string) {
    return new Buffer(Base64Words.toBase64(string), 'base64');
  };

  randomBytes = process.platform !== "win32" ? function(n) {
    return promise(function(resolve, reject) {
      return fs.open("/dev/urandom", "r", function(error, fd) {
        var buffer;
        buffer = Buffer.alloc(n);
        return fs.read(fd, buffer, 0, n, 0, function(error, m) {
          if (n === m) {
            return resolve(buffer);
          } else {
            return reject("Unable to read " + n + " bytes from /dev/urandom");
          }
        });
      });
    });
  } : function(n) {
    return promise(function(resolve, reject) {
      return Crypto.randomBytes(n, function(error, buffer) {
        if (error == null) {
          return resolve(buffer);
        } else {
          return reject(error);
        }
      });
    });
  };

  randomKey = async(function*(n) {
    return base64URL((yield randomBytes(n)));
  });

  randomWords = async(function*(n) {
    return toBase64Words((yield randomBytes(n)));
  });

  module.exports = {
    md5: md5,
    base64: base64,
    base64URL: base64URL,
    toBase64Words: toBase64Words,
    fromBase64Words: fromBase64Words,
    randomBytes: randomBytes,
    randomKey: randomKey,
    randomWords: randomWords
  };

}).call(this);
