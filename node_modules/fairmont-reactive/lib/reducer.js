// Generated by CoffeeScript 1.9.3
(function() {
  var Method, _flatten, add, all, any, assoc, async, average, binary, collect, curry, delimit, each, first, flatten, fold, foldr, isAsyncIterable, isAsyncIterator, isAsyncIteratorFunction, isDefined, isIterable, isIterator, isIteratorFunction, iterator, iteratorFunction, join, negate, push, reduce, reduceRight, ref, ref1, ref2, second, sum, ternary, unzip, zip;

  ref = require("./iterator"), isIterable = ref.isIterable, isAsyncIterable = ref.isAsyncIterable, iterator = ref.iterator, isIterator = ref.isIterator, isAsyncIterator = ref.isAsyncIterator, isIteratorFunction = ref.isIteratorFunction, isAsyncIteratorFunction = ref.isAsyncIteratorFunction, iteratorFunction = ref.iteratorFunction;

  ref1 = require("fairmont-core"), curry = ref1.curry, binary = ref1.binary, ternary = ref1.ternary, negate = ref1.negate;

  ref2 = require("fairmont-helpers"), isDefined = ref2.isDefined, async = ref2.async, push = ref2.push, first = ref2.first, second = ref2.second, add = ref2.add;

  Method = require("fairmont-multimethods").Method;

  fold = Method.create();

  Method.define(fold, (function() {
    return true;
  }), Function, isDefined, function(x, f, y) {
    return fold(x, f, iteratorFunction(y));
  });

  Method.define(fold, (function() {
    return true;
  }), Function, isIteratorFunction, function(x, f, i) {
    var done, ref3, value;
    while (true) {
      ref3 = i(), done = ref3.done, value = ref3.value;
      if (done) {
        break;
      }
      x = f(x, value);
    }
    return x;
  });

  Method.define(fold, (function() {
    return true;
  }), Function, isAsyncIteratorFunction, async(function*(x, f, i) {
    var done, ref3, value;
    while (true) {
      ref3 = (yield i()), done = ref3.done, value = ref3.value;
      if (done) {
        break;
      }
      x = f(x, value);
    }
    return x;
  }));

  reduce = fold = curry(ternary(fold));

  foldr = Method.create();

  Method.define(foldr, (function() {
    return true;
  }), Function, isDefined, function(x, f, y) {
    return foldr(x, f, iteratorFunction(y));
  });

  Method.define(foldr, (function() {
    return true;
  }), Function, isIteratorFunction, function(x, f, i) {
    return (collect(i)).reduceRight(f, x);
  });

  Method.define(foldr, (function() {
    return true;
  }), Function, isAsyncIteratorFunction, async(function*(x, f, i) {
    return ((yield collect(i))).reduceRight(f, x);
  }));

  reduceRight = foldr = curry(ternary(foldr));

  collect = function(i) {
    return reduce([], push, i);
  };

  each = curry(function(f, i) {
    var g;
    g = function(_, x) {
      f(x);
      return _;
    };
    return reduce(void 0, g, i);
  });

  any = Method.create();

  Method.define(any, Function, isDefined, function(f, x) {
    return any(f, iteratorFunction(x));
  });

  Method.define(any, Function, isIteratorFunction, function(f, i) {
    var done, ref3, value;
    while (true) {
      ref3 = i(), done = ref3.done, value = ref3.value;
      if (done || (f(value))) {
        break;
      }
    }
    return !done;
  });

  Method.define(any, Function, isAsyncIteratorFunction, async(function*(f, i) {
    var done, ref3, value;
    while (true) {
      ref3 = (yield i()), done = ref3.done, value = ref3.value;
      if (done || (f(value))) {
        break;
      }
    }
    return !done;
  }));

  any = curry(binary(any));

  all = Method.create();

  Method.define(all, Function, isDefined, function(f, x) {
    return all(f, iteratorFunction(x));
  });

  Method.define(all, Function, isIteratorFunction, function(f, i) {
    return !any(negate(f), i);
  });

  Method.define(all, Function, isAsyncIteratorFunction, async(function*(f, i) {
    return !((yield any(negate(f), i)));
  }));

  all = curry(binary(all));

  zip = Method.create();

  Method.define(zip, Function, isDefined, isDefined, function(f, x, y) {
    return zip(f, iteratorFunction(x), iteratorFunction(y));
  });

  Method.define(zip, Function, isIteratorFunction, isIteratorFunction, function(f, i, j) {
    return iterator(function() {
      var x, y;
      x = i();
      y = j();
      if (!x.done && !y.done) {
        return {
          value: f(x.value, y.value),
          done: false
        };
      } else {
        return {
          done: true
        };
      }
    });
  });

  unzip = function(f, i) {
    return fold([[], []], f, i);
  };

  assoc = Method.create();

  Method.define(assoc, isDefined, function(x) {
    return assoc(iteratorFunction(x));
  });

  Method.define(assoc, isIteratorFunction, function(i) {
    var done, ref3, result, value;
    result = {};
    while (true) {
      ref3 = i(), done = ref3.done, value = ref3.value;
      if (done) {
        break;
      }
      result[first(value)] = second(value);
    }
    return result;
  });

  Method.define(assoc, isAsyncIteratorFunction, function*(i) {
    var done, ref3, result, value;
    result = {};
    while (true) {
      ref3 = (yield i()), done = ref3.done, value = ref3.value;
      if (done) {
        break;
      }
      result[first(value)] = second(value);
    }
    return result;
  });

  _flatten = function(ax, a) {
    if (isIterable(a)) {
      return ax.concat(flatten(a));
    } else {
      ax.push(a);
      return ax;
    }
  };

  flatten = fold([], _flatten);

  sum = fold(0, add);

  average = function(i) {
    var f, j;
    j = 0;
    f = function(r, n) {
      return r += (n - r) / ++j;
    };
    return fold(0, f, i);
  };

  join = fold("", add);

  delimit = curry(function(d, i) {
    var f;
    f = function(r, s) {
      if (r === "") {
        return r += s;
      } else {
        return r += d + s;
      }
    };
    return fold("", f, i);
  });

  module.exports = {
    collect: collect,
    each: each,
    fold: fold,
    reduce: reduce,
    foldr: foldr,
    reduceRight: reduceRight,
    any: any,
    all: all,
    zip: zip,
    unzip: unzip,
    assoc: assoc,
    flatten: flatten,
    sum: sum,
    average: average,
    join: join,
    delimit: delimit
  };

}).call(this);
