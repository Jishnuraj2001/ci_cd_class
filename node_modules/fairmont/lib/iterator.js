// Generated by CoffeeScript 1.9.3
(function() {
  var assert, describe, ref,
    slice = [].slice;

  ref = require("./helpers"), assert = ref.assert, describe = ref.describe;

  describe("Iterator functions", function(context) {
    var $, Method, _flatten, add, all, any, assoc, async, asyncIterator, average, binary, cat, collect, compact, compose, curry, delimit, each, either, events, filter, first, flatten, fold, foldr, has, identity, isAsyncIterable, isAsyncIterator, isAsyncIteratorFunction, isDefined, isFunction, isGenerator, isIterable, isIterator, isIteratorFunction, isPromise, isSource, iterator, iteratorFunction, join, lines, map, negate, partition, project, promise, property, query, reduce, reduceRight, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, reject, repeat, resolve, second, select, split, stream, sum, take, takeN, ternary, unzip, where, zip;
    isIterable = function(x) {
      return (x != null ? x[Symbol.iterator] : void 0) != null;
    };
    context.test("isIterable", function() {
      return assert(isIterable([1, 2, 3]));
    });
    isAsyncIterable = function(x) {
      return (x != null ? x[Symbol.asyncIterator] : void 0) != null;
    };
    isIterator = function(x) {
      return ((x != null ? x.next : void 0) != null) && isIterable(x);
    };
    isAsyncIterator = function(x) {
      return ((x != null ? x.next : void 0) != null) && isAsyncIterable(x);
    };
    Method = require("./multimethods").Method;
    iterator = Method.create();
    isFunction = require("./type").isFunction;
    Method.define(iterator, isFunction, function(f) {
      f.next = f;
      f[Symbol.iterator] = function() {
        return this["this"];
      };
      return f;
    });
    isGenerator = require("./type").isGenerator;
    async = require("./generator").async;
    Method.define(iterator, isGenerator, function(g) {
      var f;
      f = async(g);
      f.next = f;
      f[Symbol.asyncIterator] = function() {
        return this["this"];
      };
      return f;
    });
    Method.define(iterator, isIterable, function(i) {
      return i[Symbol.iterator]();
    });
    Method.define(iterator, isAsyncIterable, function(i) {
      return i[Symbol.asyncIterator]();
    });
    asyncIterator = Method.create();
    Method.define(asyncIterator, isFunction, function(f) {
      f.next = f;
      f[Symbol.asyncIterator] = function() {
        return this["this"];
      };
      return f;
    });
    Method.define(iterator, isGenerator, function(g) {
      var f;
      f = async(g);
      f.next = f;
      f[Symbol.asyncIterator] = function() {
        return this["this"];
      };
      return f;
    });
    Method = require("./multimethods").Method;
    iteratorFunction = Method.create();
    isFunction = require("./type").isFunction;
    isIteratorFunction = function(f) {
      return (isFunction(f)) && (isIterator(f));
    };
    isAsyncIteratorFunction = function(f) {
      return (isFunction(f)) && (isAsyncIterator(f));
    };
    either = require("./logical").either;
    Method.define(iteratorFunction, either(isIterable, isAsyncIterable), function(x) {
      return iteratorFunction(iterator(x));
    });
    Method.define(iteratorFunction, either(isIterator, isAsyncIterator), function(i) {
      return iterator((function() {
        return i.next();
      }));
    });
    either = require("./logical").either;
    ref1 = require("./type"), isFunction = ref1.isFunction, isGenerator = ref1.isGenerator;
    Method.define(iteratorFunction, either(isFunction, isGenerator), function(f) {
      return iterator(f);
    });
    either = require("./logical").either;
    identity = require("./core").identity;
    Method.define(iteratorFunction, either(isIteratorFunction, isAsyncIteratorFunction), identity);
    context.test("iteratorFunction", function() {
      return assert(isIteratorFunction(iteratorFunction([1, 2, 3, 4, 5])));
    });
    repeat = function(x) {
      return iterator(function() {
        return {
          done: false,
          value: x
        };
      });
    };
    $ = (function() {
      return true;
    });
    Method = require("./multimethods").Method;
    collect = Method.create();
    Method.define(collect, $, function(x) {
      return collect(iteratorFunction(x));
    });
    Method.define(collect, isIteratorFunction, function(i) {
      var done, ref2, results, value;
      results = [];
      while (true) {
        ref2 = i(), done = ref2.done, value = ref2.value;
        if (done) {
          break;
        }
        results.push(value);
      }
      return results;
    });
    async = require("./generator").async;
    Method.define(collect, isAsyncIteratorFunction, async(function*(i) {
      var done, ref2, results, value;
      results = [];
      while (true) {
        ref2 = (yield i()), done = ref2.done, value = ref2.value;
        if (done) {
          break;
        }
        results.push(value);
      }
      return results;
    }));
    context.test("collect", function() {
      var first;
      first = require("./array").first;
      return assert((first(collect([1, 2, 3, 4, 5]))) === 1);
    });
    map = Method.create();
    Method.define(map, Function, $, function(f, x) {
      return map(f, iteratorFunction(x));
    });
    isPromise = require("./type").isPromise;
    Method.define(map, Function, isPromise, async(function*(f, p) {
      return map(f, (yield p));
    }));
    Method.define(map, Function, isIteratorFunction, function(f, i) {
      return iterator(function() {
        var done, ref2, value;
        ref2 = i(), done = ref2.done, value = ref2.value;
        if (done) {
          return {
            done: done
          };
        } else {
          return {
            done: done,
            value: f(value)
          };
        }
      });
    });
    Method.define(map, Function, isAsyncIteratorFunction, function(f, i) {
      return iterator(function*() {
        var done, ref2, value;
        ref2 = (yield i()), done = ref2.done, value = ref2.value;
        if (!done) {
          value = f(value);
          if (isPromise(value)) {
            value = (yield value);
          }
        }
        return {
          done: done,
          value: value
        };
      });
    });
    ref2 = require("./core"), curry = ref2.curry, binary = ref2.binary;
    map = curry(binary(map));
    context.test("map", function() {
      var i;
      i = map(Math.sqrt, [1, 4, 9]);
      assert(i().value === 1);
      assert(i().value === 2);
      assert(i().value === 3);
      return assert(i().done);
    });
    ref3 = require("./core"), curry = ref3.curry, compose = ref3.compose, binary = ref3.binary;
    each = curry(binary(compose(collect, map)));
    context.test("each", function() {
      var last;
      last = require("./array").last;
      return assert((last(each((function(x) {
        return x + 1;
      }), [1, 2, 3, 4, 5]))) === 6);
    });
    ref4 = require("./core"), curry = ref4.curry, ternary = ref4.ternary;
    fold = Method.create();
    Method.define(fold, $, Function, $, function(x, f, y) {
      return fold(x, f, iteratorFunction(y));
    });
    Method.define(fold, $, Function, isIteratorFunction, function(x, f, i) {
      var done, ref5, value;
      while (true) {
        ref5 = i(), done = ref5.done, value = ref5.value;
        if (done) {
          break;
        }
        x = f(x, value);
      }
      return x;
    });
    Method.define(fold, $, Function, isAsyncIteratorFunction, async(function*(x, f, i) {
      var done, ref5, value;
      while (true) {
        ref5 = (yield i()), done = ref5.done, value = ref5.value;
        if (done) {
          break;
        }
        x = f(x, value);
      }
      return x;
    }));
    reduce = fold = curry(ternary(fold));
    add = require("./numeric").add;
    context.test("fold/reduce", function() {
      var sum;
      sum = fold(0, add);
      return assert((sum([1, 2, 3, 4, 5])) === 15);
    });
    ref5 = require("./core"), curry = ref5.curry, ternary = ref5.ternary;
    foldr = Method.create();
    Method.define(foldr, $, Function, $, function(x, f, y) {
      return foldr(x, f, iteratorFunction(y));
    });
    Method.define(foldr, $, Function, isIteratorFunction, function(x, f, i) {
      return (collect(i)).reduceRight(f, x);
    });
    Method.define(foldr, $, Function, isAsyncIteratorFunction, async(function*(x, f, i) {
      return ((yield collect(i))).reduceRight(f, x);
    }));
    reduceRight = foldr = curry(ternary(foldr));
    add = require("./numeric").add;
    context.test("foldr/reduceRight", function() {
      return assert((foldr("", add, "panama")) === "amanap");
    });
    select = Method.create();
    Method.define(select, Function, $, function(f, x) {
      return select(f, iteratorFunction(x));
    });
    Method.define(select, Function, isIteratorFunction, function(f, i) {
      return iterator(function() {
        var done, ref6, value;
        while (true) {
          ref6 = i(), done = ref6.done, value = ref6.value;
          if (done || (f(value))) {
            break;
          }
        }
        return {
          done: done,
          value: value
        };
      });
    });
    Method.define(select, Function, isAsyncIteratorFunction, function(f, i) {
      return iterator(function*() {
        var done, ref6, value;
        while (true) {
          ref6 = (yield i()), done = ref6.done, value = ref6.value;
          if (done || (f(value))) {
            break;
          }
        }
        return {
          done: done,
          value: value
        };
      });
    });
    ref6 = require("./core"), binary = ref6.binary, curry = ref6.curry;
    select = filter = curry(binary(select));
    context.test("select", function() {
      var i, odd;
      odd = require("./numeric").odd;
      i = select(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
      assert(i().value === 1);
      return assert(i().value === 3);
    });
    negate = require("./logical").negate;
    reject = curry(function(f, i) {
      return select(negate(f), i);
    });
    context.test("reject", function() {
      var i, odd;
      odd = require("./numeric").odd;
      i = reject(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9]);
      assert(i().value === 2);
      return assert(i().value === 4);
    });
    any = Method.create();
    Method.define(any, Function, $, function(f, x) {
      return any(f, iteratorFunction(x));
    });
    Method.define(any, Function, isIteratorFunction, function(f, i) {
      var done, ref7, value;
      while (true) {
        ref7 = i(), done = ref7.done, value = ref7.value;
        if (done || (f(value))) {
          break;
        }
      }
      return !done;
    });
    Method.define(any, Function, isAsyncIteratorFunction, async(function*(f, i) {
      var done, ref7, value;
      while (true) {
        ref7 = (yield i()), done = ref7.done, value = ref7.value;
        if (done || (f(value))) {
          break;
        }
      }
      return !done;
    }));
    ref7 = require("./core"), curry = ref7.curry, binary = ref7.binary;
    any = curry(binary(any));
    context.test("any", function() {
      var odd;
      odd = require("./numeric").odd;
      assert(any(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9]));
      return assert(!(any(odd, [2, 4, 6])));
    });
    all = Method.create();
    Method.define(all, Function, $, function(f, x) {
      return all(f, iteratorFunction(x));
    });
    Method.define(all, Function, isIteratorFunction, function(f, i) {
      return !any(negate(f), i);
    });
    Method.define(all, Function, isAsyncIteratorFunction, async(function*(f, i) {
      return !((yield any(negate(f), i)));
    }));
    all = curry(binary(all));
    context.test("all", function() {
      var odd;
      odd = require("./numeric").odd;
      assert(!(all(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9])));
      return assert(all(odd, [1, 3, 5]));
    });
    zip = Method.create();
    Method.define(zip, Function, $, $, function(f, x, y) {
      return zip(f, iteratorFunction(x), iteratorFunction(y));
    });
    Method.define(zip, Function, isIteratorFunction, isIteratorFunction, function(f, i, j) {
      return iterator(function() {
        var x, y;
        x = i();
        y = j();
        if (!x.done && !y.done) {
          return {
            value: f(x.value, y.value),
            done: false
          };
        } else {
          return {
            done: true
          };
        }
      });
    });
    context.test("zip", function() {
      var i, pair;
      pair = function(x, y) {
        return [x, y];
      };
      i = zip(pair, [1, 2, 3], [4, 5, 6]);
      assert(i().value[0] === 1);
      assert(i().value[1] === 5);
      assert(i().value[0] === 3);
      return assert(i().done);
    });
    unzip = function(f, i) {
      return fold([[], []], f, i);
    };
    context.test("unzip", function() {
      var pair, unpair;
      pair = function(x, y) {
        return [x, y];
      };
      unpair = function(arg, arg1) {
        var a, ax, b, bx;
        ax = arg[0], bx = arg[1];
        a = arg1[0], b = arg1[1];
        ax.push(a);
        bx.push(b);
        return [ax, bx];
      };
      return assert((unzip(unpair, zip(pair, "panama", "canary")))[0][0] === "p");
    });
    ref8 = require("./array"), first = ref8.first, second = ref8.second;
    assoc = Method.create();
    Method.define(assoc, $, function(x) {
      return assoc(iteratorFunction(x));
    });
    Method.define(assoc, isIteratorFunction, function(i) {
      var done, ref9, result, value;
      result = {};
      while (true) {
        ref9 = i(), done = ref9.done, value = ref9.value;
        if (done) {
          break;
        }
        result[first(value)] = second(value);
      }
      return result;
    });
    Method.define(assoc, isAsyncIteratorFunction, function*(i) {
      var done, ref9, result, value;
      result = {};
      while (true) {
        ref9 = (yield i()), done = ref9.done, value = ref9.value;
        if (done) {
          break;
        }
        result[first(value)] = second(value);
      }
      return result;
    });
    context.test("assoc", function() {
      return assert((assoc([["foo", 1], ["bar", 2]])).foo === 1);
    });
    property = require("./object").property;
    curry = require("./core").curry;
    project = curry(function(p, i) {
      return map(property(p), i);
    });
    context.test("project", function() {
      var i, w;
      w = require("./string").w;
      i = project("length", w("one two three"));
      return assert(i().value === 3);
    });
    _flatten = function(ax, a) {
      if (isIterable(a)) {
        return ax.concat(flatten(a));
      } else {
        ax.push(a);
        return ax;
      }
    };
    flatten = fold([], _flatten);
    context.test("flatten", function() {
      return assert((flatten([1, [2, 3], 4, [5, [6, 7]]]))[1] === 2);
    });
    isDefined = require("./type").isDefined;
    compact = select(isDefined);
    context.test("compact", function() {
      var i;
      i = compact([1, null, null, 2]);
      assert(i().value === 1);
      return assert(i().value === 2);
    });
    partition = Method.create();
    Method.define(partition, Number, $, function(n, x) {
      return partition(n, iteratorFunction(x));
    });
    Method.define(partition, Number, isIteratorFunction, function(n, i) {
      return iterator(function() {
        var batch, done, ref9, value;
        batch = [];
        while (true) {
          ref9 = i(), done = ref9.done, value = ref9.value;
          if (done) {
            break;
          }
          batch.push(value);
          if (batch.length === n) {
            break;
          }
        }
        if (done) {
          return {
            done: done
          };
        } else {
          return {
            value: batch,
            done: done
          };
        }
      });
    });
    Method.define(partition, Number, isAsyncIteratorFunction, function(n, i) {
      return iterator(function*() {
        var batch, done, ref9, value;
        batch = [];
        while (true) {
          ref9 = (yield i()), done = ref9.done, value = ref9.value;
          if (done) {
            break;
          }
          batch.push(value);
          if (batch.length === n) {
            break;
          }
        }
        if (done) {
          return {
            done: done
          };
        } else {
          return {
            value: batch,
            done: done
          };
        }
      });
    });
    context.test("partition", function() {
      var i;
      i = partition(2, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
      assert(i().value[0] === 0);
      return assert(i().value[0] === 2);
    });
    add = require("./numeric").add;
    sum = fold(0, add);
    context.test("sum", function() {
      return assert((sum([1, 2, 3, 4, 5])) === 15);
    });
    average = function(i) {
      var f, j;
      j = 0;
      f = function(r, n) {
        return r += (n - r) / ++j;
      };
      return fold(0, f, i);
    };
    context.test("average", function() {
      assert((average([1, 2, 3, 4, 5])) === 3);
      return assert((average([-5, -4, -3, -2, -1])) === -3);
    });
    take = Method.create();
    Method.define(take, Function, $, function(f, x) {
      return take(f, iteratorFunction(x));
    });
    Method.define(take, Function, isIteratorFunction, function(f, i) {
      return iterator(function() {
        var done, ref9, value;
        if (!done) {
          ref9 = i(), done = ref9.done, value = ref9.value;
          if (!done && (f(value))) {
            return {
              value: value,
              done: false
            };
          } else {
            return {
              done: true
            };
          }
        }
      });
    });
    take = curry(binary(take));
    context.test("take");
    takeN = (function() {
      var f;
      f = function(n, i) {
        if (i == null) {
          i = 0;
        }
        return function() {
          return i++ < n;
        };
      };
      return function(n, i) {
        return take(f(n), i);
      };
    })();
    context.test("takeN", function() {
      var i;
      i = takeN(3, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
      assert(i().value === 0);
      assert(i().value === 1);
      assert(i().value === 2);
      return assert(i().done);
    });
    cat = require("./array").cat;
    join = fold("", add);
    context.test("join", function() {
      var w;
      w = require("./string").w;
      return assert((join(w("one two three"))) === "onetwothree");
    });
    delimit = curry(function(d, i) {
      var f;
      f = function(r, s) {
        if (r === "") {
          return r += s;
        } else {
          return r += d + s;
        }
      };
      return fold("", f, i);
    });
    context.test("delimit", function() {
      var w;
      w = require("./string").w;
      return assert((delimit(", ", w("one two three"))) === "one, two, three");
    });
    query = require("./object").query;
    where = curry(function(example, i) {
      return select(query(example), i);
    });
    context.test("where", function() {
      var pair;
      pair = function(x, y) {
        return [x, y];
      };
      return assert((collect(where(["a", 1], zip(pair, repeat("a"), [1, 2, 3, 1, 2, 3])))).length === 2);
    });
    ref9 = require("when"), promise = ref9.promise, reject = ref9.reject, resolve = ref9.resolve;
    has = require("./object").has;
    events = Method.create();
    isSource = compose(isFunction, property("on"));
    Method.define(events, String, isSource, function(name, source) {
      return events({
        name: name,
        end: "end",
        error: "error"
      }, source);
    });
    Method.define(events, Object, isSource, function(map, source) {
      var dequeue, done, end, enqueue, error, name, pending, resolved;
      name = map.name, end = map.end, error = map.error;
      done = false;
      pending = [];
      resolved = [];
      enqueue = function(x) {
        var p;
        if (pending.length === 0) {
          return resolved.push(x);
        } else {
          p = pending.shift();
          return x.then(p.resolve)["catch"](p.reject);
        }
      };
      dequeue = function() {
        if (resolved.length === 0) {
          if (!done) {
            return promise(function(resolve, reject) {
              return pending.push({
                resolve: resolve,
                reject: reject
              });
            });
          } else {
            return resolve({
              done: done
            });
          }
        } else {
          return resolved.shift();
        }
      };
      source.on(name, function() {
        var ax, value;
        ax = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        value = ax.length < 2 ? ax[0] : ax;
        return enqueue(resolve({
          done: done,
          value: value
        }));
      });
      source.on(end, function(error) {
        return done = true;
      });
      source.on(error, function(error) {
        return enqueue(reject(error));
      });
      return asyncIterator(dequeue);
    });
    events = curry(binary(events));
    context.test("events", function*() {
      var createReadStream, i;
      createReadStream = require("fs").createReadStream;
      i = events("data", createReadStream("test/lines.txt"));
      assert(((yield i())).value.toString() === "one\ntwo\nthree\n");
      return console.log((yield i()));
    });
    stream = events("data");
    context.test("stream", function*() {
      var createReadStream, i;
      createReadStream = require("fs").createReadStream;
      i = stream(createReadStream("test/lines.txt"));
      assert(((yield i())).value === "one\ntwo\nthree\n");
      return assert(((yield i())).done);
    });
    split = Method.create();
    Method.define(split, Function, $, function(f, x) {
      return split(f, iteratorFunction(x));
    });
    Method.define(split, Function, isIteratorFunction, function(f, i) {
      var lines, remainder;
      lines = [];
      remainder = "";
      return iterator(function() {
        var done, k, last, ref10, ref11, value;
        if (lines.length > 0) {
          return {
            value: lines.shift(),
            done: false
          };
        } else {
          ref10 = i(), value = ref10.value, done = ref10.done;
          if (!done) {
            ref11 = f(value), first = ref11[0], lines = 3 <= ref11.length ? slice.call(ref11, 1, k = ref11.length - 1) : (k = 1, []), last = ref11[k++];
            first = remainder + first;
            remainder = last;
            return {
              value: first,
              done: done
            };
          } else if (remainder !== "") {
            value = remainder;
            remainder = "";
            return {
              value: value,
              done: false
            };
          } else {
            return {
              done: done
            };
          }
        }
      });
    });
    Method.define(split, Function, isAsyncIteratorFunction, function(f, i) {
      var lines, remainder;
      lines = [];
      remainder = "";
      return iterator(function*() {
        var done, k, last, ref10, ref11, value;
        if (lines.length > 0) {
          return {
            value: lines.shift(),
            done: false
          };
        } else {
          ref10 = (yield i()), value = ref10.value, done = ref10.done;
          if (!done) {
            ref11 = f(value), first = ref11[0], lines = 3 <= ref11.length ? slice.call(ref11, 1, k = ref11.length - 1) : (k = 1, []), last = ref11[k++];
            first = remainder + first;
            remainder = last;
            return {
              value: first,
              done: done
            };
          } else if (remainder !== "") {
            value = remainder;
            remainder = "";
            return {
              value: value,
              done: false
            };
          } else {
            return {
              done: done
            };
          }
        }
      });
    });
    split = curry(binary(split));
    context.test("split", function() {
      var i;
      i = split((function(x) {
        return x.split("\n");
      }), ["one\ntwo\n", "three\nfour"]);
      assert(i().value === "one");
      assert(i().value === "two");
      assert(i().value === "three");
      assert(i().value === "four");
      return assert(i().done);
    });
    lines = split(function(s) {
      return s.toString().split("\n");
    });
    context.test("lines", function*() {
      var createReadStream, i;
      createReadStream = require("fs").createReadStream;
      i = lines(stream(createReadStream("test/lines.txt")));
      assert(((yield i())).value === "one");
      assert(((yield i())).value === "two");
      assert(((yield i())).value === "three");
      return assert(((yield i())).done);
    });
    return module.exports = {
      isIterable: isIterable,
      isAsyncIterable: isAsyncIterable,
      iterator: iterator,
      isIterator: isIterator,
      isAsyncIterator: isAsyncIterator,
      iteratorFunction: iteratorFunction,
      isIteratorFunction: isIteratorFunction,
      isAsyncIteratorFunction: isAsyncIteratorFunction,
      collect: collect,
      map: map,
      each: each,
      fold: fold,
      reduce: reduce,
      foldr: foldr,
      reduceRight: reduceRight,
      select: select,
      reject: reject,
      filter: filter,
      any: any,
      all: all,
      zip: zip,
      assoc: assoc,
      project: project,
      flatten: flatten,
      compact: compact,
      partition: partition,
      sum: sum,
      average: average,
      join: join,
      delimit: delimit,
      where: where,
      take: take,
      takeN: takeN,
      events: events,
      stream: stream,
      lines: lines,
      split: split
    };
  });

}).call(this);
