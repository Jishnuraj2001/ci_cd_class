// Generated by CoffeeScript 1.9.3
(function() {
  var assert, async, describe, ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require("./generator").async;

  ref = require("./helpers"), describe = ref.describe, assert = ref.assert;

  describe("File system functions", function(context) {
    var FS, Method, Minimatch, binary, chDir, chdir, curry, dirname, exist, exists, flatten, glob, isDirectory, isFile, join, liftAll, ls, lsR, lsr, mkDir, mkDirP, mkdir, mkdirp, promise, read, readBuffer, readDir, readdir, ref1, ref2, rm, rmDir, rmdir, stat, stream, write;
    liftAll = require("when/node").liftAll;
    FS = liftAll(require("fs"));
    stat = function(path) {
      return FS.stat(path);
    };
    context.test("stat", function*() {
      return assert(((yield stat("test/lines.txt"))).size != null);
    });
    exists = exist = async(function*(path) {
      try {
        (yield FS.stat(path));
        return true;
      } catch (_error) {
        return false;
      }
    });
    context.test("exists", function*() {
      assert((yield exists("test/lines.txt")));
      return assert(!((yield exists("test/does-not-exist"))));
    });
    Method = require("./multimethods").Method;
    read = Method.create();
    Method.define(read, String, String, function(path, encoding) {
      return FS.readFile(path, encoding);
    });
    Method.define(read, String, function(path) {
      return read(path, 'utf8');
    });
    readBuffer = function(path) {
      return FS.readFile(path);
    };
    Method.define(read, String, void 0, readBuffer);
    Method.define(read, String, "binary", readBuffer);
    Method.define(read, String, "buffer", readBuffer);
    stream = require("stream");
    promise = require("when").promise;
    Method.define(read, stream.Readable, function(stream) {
      var buffer;
      buffer = "";
      return promise(function(resolve, reject) {
        stream.on("data", function(data) {
          return buffer += data.toString();
        });
        stream.on("end", function() {
          return resolve(buffer);
        });
        return stream.on("error", function(error) {
          return reject(error);
        });
      });
    });
    context.test("read", function*() {
      return assert(((yield read("test/lines.txt"))) === "one\ntwo\nthree\n");
    });
    context.test("read buffer", function*() {
      return assert(((yield read("test/lines.txt", "binary"))).constructor === Buffer);
    });
    context.test("read stream", function*() {
      var createReadStream, s;
      createReadStream = require("fs").createReadStream;
      s = createReadStream("test/lines.txt");
      return assert(((yield read(s))) === "one\ntwo\nthree\n");
    });
    readdir = readDir = function(path) {
      return FS.readdir(path);
    };
    context.test("readdir", function*() {
      return assert(indexOf.call((yield readdir("test")), "lines.txt") >= 0);
    });
    ls = async(function*(path) {
      var file, i, len, ref1, results;
      ref1 = (yield readdir(path));
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        file = ref1[i];
        results.push(join(path, file));
      }
      return results;
    });
    flatten = require("./iterator").flatten;
    join = require("path").join;
    lsR = lsr = async(function*(path, visited) {
      var childPath, i, info, len, ref1;
      if (visited == null) {
        visited = [];
      }
      ref1 = (yield ls(path));
      for (i = 0, len = ref1.length; i < len; i++) {
        childPath = ref1[i];
        if (!(indexOf.call(visited, childPath) >= 0)) {
          info = (yield FS.lstat(childPath));
          if (info.isDirectory()) {
            (yield lsR(childPath, visited));
          } else {
            visited.push(childPath);
          }
        }
      }
      return visited;
    });
    context.test("lsR", function*() {
      var ref1, resolve, testDir;
      resolve = require("path").resolve;
      testDir = join(__dirname, "..");
      return assert((ref1 = join(testDir, "test/lines.txt"), indexOf.call((yield lsR(testDir)), ref1) >= 0));
    });
    Minimatch = require("minimatch").Minimatch;
    glob = async(function*(pattern, path) {
      var _path, i, len, match, minimatch, ref1, results;
      minimatch = new Minimatch(pattern);
      match = function(path) {
        return minimatch.match(path);
      };
      ref1 = (yield lsR(path));
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        _path = ref1[i];
        if (match(_path)) {
          results.push(_path);
        }
      }
      return results;
    });
    context.test("glob", function*() {
      var ref1, testDir;
      testDir = join(__dirname, "..");
      return assert((ref1 = join(testDir, "test", "test.litcoffee"), indexOf.call((yield glob("**/*.litcoffee", testDir)), ref1) >= 0));
    });
    write = function(path, content) {
      return FS.writeFile(path, content);
    };
    context.test("write", function*() {
      return write("test/lines.txt", (yield read("test/lines.txt")));
    });
    Method = require("./multimethods").Method;
    chDir = chdir = Method.create();
    Method.define(chdir, String, function(path) {
      var cwd;
      cwd = process.cwd();
      process.chdir(path);
      return function() {
        return process.chdir(cwd);
      };
    });
    Method.define(chdir, String, Function, function(path, f) {
      var restore;
      restore = chdir(path);
      f();
      return restore();
    });
    context.test("chdir", function() {
      var cwd;
      cwd = process.cwd();
      chDir("test", function() {
        var fs;
        fs = require("fs");
        return assert((fs.statSync("lines.txt")).size != null);
      });
      return assert(cwd === process.cwd());
    });
    rm = async(function(path) {
      return FS.unlink(path);
    });
    context.test("rm");
    rmDir = rmdir = function(path) {
      return FS.rmdir(path);
    };
    context.test("rmdir", function() {});
    isDirectory = async(function*(path) {
      return ((yield stat(path))).isDirectory();
    });
    context.test("isDirectory", function*() {
      return assert((yield isDirectory("./test")));
    });
    isFile = async(function*(path) {
      return ((yield stat(path))).isFile();
    });
    context.test("isFile", function*() {
      return assert((yield isFile("./test/lines.txt")));
    });
    ref1 = require("./core"), curry = ref1.curry, binary = ref1.binary;
    mkDir = mkdir = curry(binary(function(mode, path) {
      return FS.mkdir(path, mode);
    }));
    context.test("mdkir", function*() {
      (yield mkdir('0777', "./test/foobar"));
      assert((yield isDirectory("./test/foobar")));
      return (yield rmdir("./test/foobar"));
    });
    dirname = require("path").dirname;
    ref2 = require("./core"), curry = ref2.curry, binary = ref2.binary;
    mkDirP = mkdirp = curry(binary(async(function*(mode, path) {
      var parent;
      if (!((yield exists(path)))) {
        parent = dirname(path);
        if (!((yield exists(parent)))) {
          (yield mkdirp(mode, parent));
        }
        return mkdir(mode, path);
      }
    })));
    context.test("mkdirp", function*() {
      (yield mkdirp('0777', "./test/foo/bar"));
      assert((yield isDirectory("./test/foo/bar")));
      (yield rmdir("./test/foo/bar"));
      return (yield rmdir("./test/foo"));
    });
    return module.exports = {
      read: read,
      write: write,
      rm: rm,
      stat: stat,
      exist: exist,
      exists: exists,
      isFile: isFile,
      isDirectory: isDirectory,
      readdir: readdir,
      readDir: readDir,
      ls: ls,
      lsR: lsR,
      lsr: lsr,
      mkdir: mkdir,
      mkDir: mkDir,
      mkdirp: mkdirp,
      mkDirP: mkDirP,
      chdir: chdir,
      chDir: chDir,
      rmdir: rmdir,
      rmDir: rmDir
    };
  });

}).call(this);
