// Generated by CoffeeScript 1.9.3
(function() {
  var Method, assert, create, define, describe, dispatch, lookup, ref,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  lookup = function(method, ax) {
    var arg, best, bi, bx, f, i, len, p, ref, ref1, term, ti, tx;
    best = {
      p: 0,
      f: method["default"]
    };
    bx = method.map != null ? method.map.apply(method, ax) : ax;
    ref = method.entries;
    for (i = 0, len = ref.length; i < len; i++) {
      ref1 = ref[i], tx = ref1[0], f = ref1[1];
      if (tx.length === bx.length) {
        p = 0;
        bi = ti = 0;
        while (bi < bx.length && ti < tx.length) {
          term = tx[ti++];
          arg = bx[bi++];
          if (term === arg) {
            p += 5;
          } else if (arg != null) {
            if ((term != null ? term.constructor : void 0) === Function) {
              if (term === arg.constructor) {
                p += 4;
              } else if (arg instanceof term) {
                p += 2;
              } else if (arg.prototype instanceof term) {
                p += 1;
              } else if (term !== Boolean && (term(arg)) === true) {
                p += 5;
              } else {
                p = 0;
                break;
              }
            } else {
              p = 0;
              break;
            }
          } else {
            p = 0;
            break;
          }
        }
        if (p > 0 && p >= best.p) {
          best = {
            p: p,
            f: f
          };
        }
      }
    }
    if (best.f.constructor === Function) {
      return best.f;
    } else {
      return function() {
        return best.f;
      };
    }
  };

  dispatch = function(method, ax) {
    var f;
    f = lookup(method, ax);
    return f.apply(null, ax);
  };

  create = function(options) {
    var k, m, v;
    m = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return dispatch(m, args);
    };
    m.entries = [];
    for (k in options) {
      v = options[k];
      m[k] = v;
    }
    if (m["default"] == null) {
      m["default"] = function() {
        throw new TypeError("No method matches arguments.");
      };
    }
    return m;
  };

  define = function() {
    var f, i, m, terms;
    m = arguments[0], terms = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), f = arguments[i++];
    return m.entries.push([terms, f]);
  };

  Method = {
    create: create,
    define: define,
    lookup: lookup
  };

  module.exports = {
    Method: Method
  };

  ref = require("./helpers"), assert = ref.assert, describe = ref.describe;

  describe("Multimethods", function(context) {
    context.test("Fibonacci function", function() {
      var fib;
      fib = Method.create({
        description: "Fibonacci sequence"
      });
      Method.define(fib, (function(n) {
        return n <= 0;
      }), function() {
        throw new TypeError("Operand must be a postive integer");
      });
      Method.define(fib, 1, 1);
      Method.define(fib, 2, 1);
      Method.define(fib, Number, function(n) {
        return (fib(n - 1)) + (fib(n - 2));
      });
      return assert((fib(5)) === 5);
    });
    context.test("Polymorphic dispatch", function() {
      var A, B, a, b, foo;
      A = (function() {
        function A() {}

        return A;

      })();
      B = (function(superClass) {
        extend(B, superClass);

        function B() {
          return B.__super__.constructor.apply(this, arguments);
        }

        return B;

      })(A);
      a = new A;
      b = new B;
      foo = Method.create();
      Method.define(foo, A, function() {
        return "foo: A";
      });
      Method.define(foo, B, function() {
        return "foo: B";
      });
      Method.define(foo, A, B, function() {
        return "foo: A + B";
      });
      Method.define(foo, B, A, function() {
        return "foo: B + A";
      });
      Method.define(foo, a, b, function() {
        return "foo: a + b";
      });
      assert((foo(b)) === "foo: B");
      assert((foo(a, b)) === "foo: a + b");
      assert((foo(b, a)) === "foo: B + A");
      return assert.throws(function() {
        return foo(b, a, b);
      });
    });
    context.test("Variadic arguments", function() {
      var bar;
      bar = Method.create({
        map: function(x) {
          return [x];
        }
      });
      Method.define(bar, String, function() {
        var a, x;
        x = arguments[0], a = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return a[0];
      });
      Method.define(bar, Number, function() {
        var a, x;
        x = arguments[0], a = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return x;
      });
      return assert((bar("foo", 1, 2, 3)) === 1);
    });
    context.test("Predicate functions", function() {
      var baz;
      baz = Method.create();
      Method.define(baz, Boolean, function() {
        return false;
      });
      Method.define(baz, (function(x) {
        return x === 7;
      }), function(x) {
        return true;
      });
      assert(baz(7));
      return assert.throws(function() {
        return baz(6);
      });
    });
    context.test("Class methods", function() {
      var A, B, foo;
      A = (function() {
        function A() {}

        return A;

      })();
      B = (function(superClass) {
        extend(B, superClass);

        function B() {
          return B.__super__.constructor.apply(this, arguments);
        }

        return B;

      })(A);
      foo = Method.create();
      Method.define(foo, A, function() {
        return true;
      });
      return assert(foo(B));
    });
    context.test("Multimethods are functions", function() {
      return assert(Method.create().constructor === Function);
    });
    return context.test("Lookups", function() {
      var f, foo;
      foo = Method.create();
      Method.define(foo, Number, function(x) {
        return x + x;
      });
      Method.define(foo, String, function(x) {
        return false;
      });
      f = Method.lookup(foo, [7]);
      return assert((f(7)) === 14);
    });
  });

}).call(this);
